
# 问题

- Controller和Decoder需要分开吗？这涉及到Decoder是否需要向Controller传输控制信号的问题
	- 如果分开
		- Decoder应该将所有的小指令add,sub,..，作为位宽为 1 的port向Controller输出（相当于一个大型的多路选择器）
		- Controller来决定各个控制信号

# 设计

基本组件：
- IFetch：取指器
- Decoder：译码器
- ALU：计算逻辑单元
- DataMem：数据内存
- Controller：控制器
## Decoder 译码器
- 组件
	- RegisterFile：寄存器堆
	- ImmGen：用于立即数扩展
	
- 信号
- 时序/组合
	- 组合读，时序写
	- 只有 clk posedge 且 regWrite = 1 才会写数据

## IFetch 取指器
- 组件：
	- InstMem
	- PC寄存器



## ALU 算数逻辑单元





# 命名规范

- 模块
	- 首字母大写，大驼峰命名规则
- 端口 / 信号
	- 首字母小写，大驼峰命名规则
- 常数/ 指令类型 / 标志物
	- 全部大写

### 指令编码和命名规范




# 测试
Verilator 仿真器，

Unicorn CPU模拟器，用于差分测试（对拍）

首先在 Verilator 仿真器下 ，可以通过自己编写 C++ 代码和仿真器进行交互，当然也可以获取到每条信号的值是多少。 然后只要把这些信号的值和标准的值对比一下，就知道对不对了。 那…这个“标准的值”哪来呢？这里可以用 unicorn 仿真器（这两个“仿真器”的意思是有点区别的），它是一个开源的轻量级的支持 RISC-V 32 位的仿真器，~~几千 star 的开源项目肯定靠谱（至少比自己写的靠谱）~~。 于是我们就可以在每一轮，首先让自己的 CPU 跑一个周期，再让仿真器跑一个周期，然后对比一下两者的寄存器的值是否一致，如果不一致就打印出当前指令的细节，然后停止。 这样就可以非常方便地定位到代码错在哪个地方，而且还可以生成波形图，通过比较错误位置的一些信号的值，就可以很容易知道是哪里错了。
